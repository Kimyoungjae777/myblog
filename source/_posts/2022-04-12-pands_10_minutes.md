---
title: "pandas's 10minutes"
author: "Young Jae Kim"
date: '2022-03-16'
category: Pandas
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>



```python
import pandas as pd 
import numpy as np
import matplotlib.pyplot as plt
```

# pandas 10분 완성

- 출처-BSD-3-Clause


- 1. Object Creation(객체생성)

pandas 는  값을 가지고 있는 리스트를 통해 Series를 만들고, 정수로 만들어진 인덱스를 기본값으로 불러올 것 입니다.



```python
s=pd.Series([1,3,5,np.nan,6,8])
s
```

<pre>
0    1.0
1    3.0
2    5.0
3    NaN
4    6.0
5    8.0
dtype: float64
</pre>
datetime 인덱스와 레이블이 있는 열을 가지고 있는 numpy 배열을 전달하여 데이터프레임을 만듭니다.



```python
dates=pd.date_range('20130101',periods=6)
dates 
df=pd.DataFrame(np.random.randn(6,4),index=dates,columns=list('ABCD'))
# value 에 값을 넣어주고 , index 에는 date를 넣어주고, 컬럼에는 ABCD
df
```

<pre>
                   A         B         C         D
2013-01-01  0.867751  0.483668  0.804306 -0.943246
2013-01-02 -0.947881  0.482789 -0.044766 -0.799984
2013-01-03  0.089794  0.407933 -0.081971  1.088698
2013-01-04 -0.671818  1.295661 -0.677348  0.135460
2013-01-05  0.519066 -1.204134  1.747446  0.641655
2013-01-06 -0.528972 -0.741428  0.454718 -0.983917
</pre>
- Series 와 같은 것으로 변환될 수 있는 객체들의 dict로 구성된 데이터프레임을 만듭니다. 




```python
d2=pd.DataFrame({'A':1,
                 'B':pd.Timestamp('20130102'),
                 'C':pd.Series(1,index=list(range(4)),dtype='float32'),
                 'D':np.array([3]*4,dtype='int32'),
                 'E':pd.Categorical(["test","train","test","train"]),
                 'F':'foo'})

d2
```

<pre>
   A          B    C  D      E    F
0  1 2013-01-02  1.0  3   test  foo
1  1 2013-01-02  1.0  3  train  foo
2  1 2013-01-02  1.0  3   test  foo
3  1 2013-01-02  1.0  3  train  foo
</pre>

```python
d2.dtypes   # 다양한 데이터 타입으로 저장
```

<pre>
A             int64
B    datetime64[ns]
C           float32
D             int32
E          category
F            object
dtype: object
</pre>
# 2.Viewing Data (데이터 확인하기.)



```python
df.tail(3)# 데이터프레임을 끝에서 3줄만 출력
```

<pre>
                   A         B         C         D
2013-01-04 -0.671818  1.295661 -0.677348  0.135460
2013-01-05  0.519066 -1.204134  1.747446  0.641655
2013-01-06 -0.528972 -0.741428  0.454718 -0.983917
</pre>

```python
print(df.index) # 인덱스를 보여주며, 인덱스의 data_type 를 알려줍니다. 
print(d2.index)
```

<pre>
DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',
               '2013-01-05', '2013-01-06'],
              dtype='datetime64[ns]', freq='D')
Int64Index([0, 1, 2, 3], dtype='int64')
</pre>

```python
print(df.columns) # 컬럼를 보여주며, 컬럼의 data_type 를 알려줍니다. 
print(d2.columns)
```

<pre>
Index(['A', 'B', 'C', 'D'], dtype='object')
Index(['A', 'B', 'C', 'D', 'E', 'F'], dtype='object')
</pre>

```python
print(df.values) # 인덱스를 보여주며, 인덱스의 data_type 를 알려줍니다. 
print(d2.values)
```

<pre>
[[ 0.86775054  0.48366818  0.80430646 -0.94324588]
 [-0.947881    0.48278913 -0.0447657  -0.79998396]
 [ 0.08979353  0.40793256 -0.08197077  1.08869764]
 [-0.67181835  1.29566098 -0.67734781  0.13546042]
 [ 0.51906627 -1.20413362  1.74744631  0.64165489]
 [-0.52897166 -0.74142796  0.4547179  -0.98391684]]
[[1 Timestamp('2013-01-02 00:00:00') 1.0 3 'test' 'foo']
 [1 Timestamp('2013-01-02 00:00:00') 1.0 3 'train' 'foo']
 [1 Timestamp('2013-01-02 00:00:00') 1.0 3 'test' 'foo']
 [1 Timestamp('2013-01-02 00:00:00') 1.0 3 'train' 'foo']]
</pre>

```python
print(df.describe())  # 데이터의 대략적인 통계적 정보요약을 보여줍니다
print(d2.describe())
```

<pre>
              A         B         C         D
count  6.000000  6.000000  6.000000  6.000000
mean  -0.112010  0.120748  0.367064 -0.143556
std    0.719004  0.919167  0.844553  0.893248
min   -0.947881 -1.204134 -0.677348 -0.983917
25%   -0.636107 -0.454088 -0.072670 -0.907430
50%   -0.219589  0.445361  0.204976 -0.332262
75%    0.411748  0.483448  0.716909  0.515106
max    0.867751  1.295661  1.747446  1.088698
         A    C    D
count  4.0  4.0  4.0
mean   1.0  1.0  3.0
std    0.0  0.0  0.0
min    1.0  1.0  3.0
25%    1.0  1.0  3.0
50%    1.0  1.0  3.0
75%    1.0  1.0  3.0
max    1.0  1.0  3.0
</pre>

```python
print(df.T)  # 데이터를 전치 합니다
print(d2.T)
```

<pre>
   2013-01-01  2013-01-02  2013-01-03  2013-01-04  2013-01-05  2013-01-06
A    0.867751   -0.947881    0.089794   -0.671818    0.519066   -0.528972
B    0.483668    0.482789    0.407933    1.295661   -1.204134   -0.741428
C    0.804306   -0.044766   -0.081971   -0.677348    1.747446    0.454718
D   -0.943246   -0.799984    1.088698    0.135460    0.641655   -0.983917
                     0                    1                    2  \
A                    1                    1                    1   
B  2013-01-02 00:00:00  2013-01-02 00:00:00  2013-01-02 00:00:00   
C                  1.0                  1.0                  1.0   
D                    3                    3                    3   
E                 test                train                 test   
F                  foo                  foo                  foo   

                     3  
A                    1  
B  2013-01-02 00:00:00  
C                  1.0  
D                    3  
E                train  
F                  foo  
</pre>

```python
print(df.sort_index(axis=1,ascending=False)) # 축 별로 정렬. axis=1 =>goddmf rlwnsdmfh 
print(df.sort_index(axis=0,ascending=False))
```

<pre>
                   D         C         B         A
2013-01-01 -0.943246  0.804306  0.483668  0.867751
2013-01-02 -0.799984 -0.044766  0.482789 -0.947881
2013-01-03  1.088698 -0.081971  0.407933  0.089794
2013-01-04  0.135460 -0.677348  1.295661 -0.671818
2013-01-05  0.641655  1.747446 -1.204134  0.519066
2013-01-06 -0.983917  0.454718 -0.741428 -0.528972
                   A         B         C         D
2013-01-06 -0.528972 -0.741428  0.454718 -0.983917
2013-01-05  0.519066 -1.204134  1.747446  0.641655
2013-01-04 -0.671818  1.295661 -0.677348  0.135460
2013-01-03  0.089794  0.407933 -0.081971  1.088698
2013-01-02 -0.947881  0.482789 -0.044766 -0.799984
2013-01-01  0.867751  0.483668  0.804306 -0.943246
</pre>

```python
df.sort_values(by='B',ascending=False) #값별로 정렬
```

<pre>
                   A         B         C         D
2013-01-04 -0.671818  1.295661 -0.677348  0.135460
2013-01-01  0.867751  0.483668  0.804306 -0.943246
2013-01-02 -0.947881  0.482789 -0.044766 -0.799984
2013-01-03  0.089794  0.407933 -0.081971  1.088698
2013-01-06 -0.528972 -0.741428  0.454718 -0.983917
2013-01-05  0.519066 -1.204134  1.747446  0.641655
</pre>
# 3.Selection (선택) 



```python
#행을 분할하는 []를 통해 선택합니다.
df[0:3]# 모든행 3열까지 출력 
```

<pre>
                   A         B         C         D
2013-01-01  0.867751  0.483668  0.804306 -0.943246
2013-01-02 -0.947881  0.482789 -0.044766 -0.799984
2013-01-03  0.089794  0.407933 -0.081971  1.088698
</pre>

```python
# 인덱스 코드로 출력 
df['20130102':'20130104']
```

<pre>
                   A         B         C         D
2013-01-02 -0.947881  0.482789 -0.044766 -0.799984
2013-01-03  0.089794  0.407933 -0.081971  1.088698
2013-01-04 -0.671818  1.295661 -0.677348  0.135460
</pre>

```python
df.loc[dates[0]] #dates 컬럼 모든것 출력
```

<pre>
A    0.867751
B    0.483668
C    0.804306
D   -0.943246
Name: 2013-01-01 00:00:00, dtype: float64
</pre>

```python
df.loc[:,['A','B']]
```

<pre>
                   A         B
2013-01-01  0.867751  0.483668
2013-01-02 -0.947881  0.482789
2013-01-03  0.089794  0.407933
2013-01-04 -0.671818  1.295661
2013-01-05  0.519066 -1.204134
2013-01-06 -0.528972 -0.741428
</pre>

```python
df.loc["20130102":'20130104',['A','B']]
```

<pre>
                   A         B
2013-01-02 -0.947881  0.482789
2013-01-03  0.089794  0.407933
2013-01-04 -0.671818  1.295661
</pre>

```python
df.loc['20130102',['A','B']]
```

<pre>
A   -0.947881
B    0.482789
Name: 2013-01-02 00:00:00, dtype: float64
</pre>

```python
df.at[dates[0],'A']
```

<pre>
0.8677505440016215
</pre>
- 위치로 선택하기 



```python
df.iloc[3]
```

<pre>
A   -0.671818
B    1.295661
C   -0.677348
D    0.135460
Name: 2013-01-04 00:00:00, dtype: float64
</pre>

```python
df.iloc[3:5,0:2]
```

<pre>
                   A         B
2013-01-04 -0.671818  1.295661
2013-01-05  0.519066 -1.204134
</pre>

```python
df
```

<pre>
                   A         B         C         D
2013-01-01  0.867751  0.483668  0.804306 -0.943246
2013-01-02 -0.947881  0.482789 -0.044766 -0.799984
2013-01-03  0.089794  0.407933 -0.081971  1.088698
2013-01-04 -0.671818  1.295661 -0.677348  0.135460
2013-01-05  0.519066 -1.204134  1.747446  0.641655
2013-01-06 -0.528972 -0.741428  0.454718 -0.983917
</pre>

```python
df.iloc[[1,2,4],[0,2]]
```

<pre>
                   A         C
2013-01-02 -0.947881 -0.044766
2013-01-03  0.089794 -0.081971
2013-01-05  0.519066  1.747446
</pre>

```python
df.iloc[1:3,:]
```

<pre>
                   A         B         C         D
2013-01-02 -0.947881  0.482789 -0.044766 -0.799984
2013-01-03  0.089794  0.407933 -0.081971  1.088698
</pre>

```python
df.iloc[:,1:3]
```

<pre>
                   B         C
2013-01-01  0.483668  0.804306
2013-01-02  0.482789 -0.044766
2013-01-03  0.407933 -0.081971
2013-01-04  1.295661 -0.677348
2013-01-05 -1.204134  1.747446
2013-01-06 -0.741428  0.454718
</pre>

```python
df.iloc[1,1]
```

<pre>
0.48278913296263115
</pre>

```python
df.iat[1,1]
```

<pre>
0.48278913296263115
</pre>
# Boolean Indexing

- 데이터를 선택하기 위해 단일 열의 값을 사용한다. 



```python
df[df.A>0]
```

<pre>
                   A         B         C         D
2013-01-01  0.867751  0.483668  0.804306 -0.943246
2013-01-03  0.089794  0.407933 -0.081971  1.088698
2013-01-05  0.519066 -1.204134  1.747446  0.641655
</pre>

```python
df[df>0]
```

<pre>
                   A         B         C         D
2013-01-01  0.867751  0.483668  0.804306       NaN
2013-01-02       NaN  0.482789       NaN       NaN
2013-01-03  0.089794  0.407933       NaN  1.088698
2013-01-04       NaN  1.295661       NaN  0.135460
2013-01-05  0.519066       NaN  1.747446  0.641655
2013-01-06       NaN       NaN  0.454718       NaN
</pre>
- 필터링을 위한 메소드 isin()을 사용합니다



```python
df2=df.copy()
```


```python
df2['E']=['one','one','two','three','four','two']
df2
```

<pre>
                   A         B         C         D      E
2013-01-01  0.867751  0.483668  0.804306 -0.943246    one
2013-01-02 -0.947881  0.482789 -0.044766 -0.799984    one
2013-01-03  0.089794  0.407933 -0.081971  1.088698    two
2013-01-04 -0.671818  1.295661 -0.677348  0.135460  three
2013-01-05  0.519066 -1.204134  1.747446  0.641655   four
2013-01-06 -0.528972 -0.741428  0.454718 -0.983917    two
</pre>

```python
df2[df2['E'].isin(['two','four'])]
print(df2)
```

<pre>
                   A         B         C         D      E
2013-01-01  0.867751  0.483668  0.804306 -0.943246    one
2013-01-02 -0.947881  0.482789 -0.044766 -0.799984    one
2013-01-03  0.089794  0.407933 -0.081971  1.088698    two
2013-01-04 -0.671818  1.295661 -0.677348  0.135460  three
2013-01-05  0.519066 -1.204134  1.747446  0.641655   four
2013-01-06 -0.528972 -0.741428  0.454718 -0.983917    two
</pre>
# setting (설정)

- 새 열을 설정하면 데이터가 인덱스 별로 자동 정렬됩니다.



```python
s1=pd.Series([1,2,3,4,5,6],index=pd.date_range('20130102',periods=6))
s1
```

<pre>
2013-01-02    1
2013-01-03    2
2013-01-04    3
2013-01-05    4
2013-01-06    5
2013-01-07    6
Freq: D, dtype: int64
</pre>

```python
df['F']=s1
```


```python
df.at[dates[0],'A']=0
df
```

<pre>
                   A         B         C         D    F
2013-01-01  0.000000  0.483668  0.804306 -0.943246  NaN
2013-01-02 -0.947881  0.482789 -0.044766 -0.799984  1.0
2013-01-03  0.089794  0.407933 -0.081971  1.088698  2.0
2013-01-04 -0.671818  1.295661 -0.677348  0.135460  3.0
2013-01-05  0.519066 -1.204134  1.747446  0.641655  4.0
2013-01-06 -0.528972 -0.741428  0.454718 -0.983917  5.0
</pre>

```python
df.iat[0,1]=0
df
```

<pre>
                   A         B         C         D    F
2013-01-01  0.000000  0.000000  0.804306 -0.943246  NaN
2013-01-02 -0.947881  0.482789 -0.044766 -0.799984  1.0
2013-01-03  0.089794  0.407933 -0.081971  1.088698  2.0
2013-01-04 -0.671818  1.295661 -0.677348  0.135460  3.0
2013-01-05  0.519066 -1.204134  1.747446  0.641655  4.0
2013-01-06 -0.528972 -0.741428  0.454718 -0.983917  5.0
</pre>

```python
df.loc[:,'D']=np.array([5]*len(df))
df
```

<pre>
                   A         B         C  D    F
2013-01-01  0.000000  0.000000  0.804306  5  NaN
2013-01-02 -0.947881  0.482789 -0.044766  5  1.0
2013-01-03  0.089794  0.407933 -0.081971  5  2.0
2013-01-04 -0.671818  1.295661 -0.677348  5  3.0
2013-01-05  0.519066 -1.204134  1.747446  5  4.0
2013-01-06 -0.528972 -0.741428  0.454718  5  5.0
</pre>
# where 연산을 설정합니다



```python
df2=df.copy()
```


```python
df2[df2>0]=-df2
df2
```

<pre>
                   A         B         C  D    F
2013-01-01  0.000000  0.000000 -0.804306 -5  NaN
2013-01-02 -0.947881 -0.482789 -0.044766 -5 -1.0
2013-01-03 -0.089794 -0.407933 -0.081971 -5 -2.0
2013-01-04 -0.671818 -1.295661 -0.677348 -5 -3.0
2013-01-05 -0.519066 -1.204134 -1.747446 -5 -4.0
2013-01-06 -0.528972 -0.741428 -0.454718 -5 -5.0
</pre>
# 4. Missing Data(결측치)

- pandas는 결측치를 표현하기 위해 주로 np.nan 값을 사용합니다. 이 방법은 기본 설정값이지만 계산에는 포함되지 않습니다. 



```python
df1=df.reindex(index=dates[0:4],columns=list(df.columns)+['E'])
df1
```

<pre>
                   A         B         C  D    F   E
2013-01-01  0.000000  0.000000  0.804306  5  NaN NaN
2013-01-02 -0.947881  0.482789 -0.044766  5  1.0 NaN
2013-01-03  0.089794  0.407933 -0.081971  5  2.0 NaN
2013-01-04 -0.671818  1.295661 -0.677348  5  3.0 NaN
</pre>

```python
df1.loc[dates[0]:dates[1],'E']=1  #0과 1행렬 E 컬럼에 1을 넣어준다.
df1
```

<pre>
                   A         B         C  D    F    E
2013-01-01  0.000000  0.000000  0.804306  5  NaN  1.0
2013-01-02 -0.947881  0.482789 -0.044766  5  1.0  1.0
2013-01-03  0.089794  0.407933 -0.081971  5  2.0  NaN
2013-01-04 -0.671818  1.295661 -0.677348  5  3.0  NaN
</pre>
- 결측치를 가지고 있는 행들을 지운다. 



```python
df1.dropna(how='any') # 어떤 컬럼이던지 결측치가 있으면 삭제해라
```

<pre>
                   A         B         C  D    F    E
2013-01-02 -0.947881  0.482789 -0.044766  5  1.0  1.0
</pre>
- 결측치를 채워넣는다.



```python
df1=df1.fillna(value=5)
df1
```

<pre>
                   A         B         C  D    F    E
2013-01-01  0.000000  0.000000  0.804306  5  5.0  1.0
2013-01-02 -0.947881  0.482789 -0.044766  5  1.0  1.0
2013-01-03  0.089794  0.407933 -0.081971  5  2.0  5.0
2013-01-04 -0.671818  1.295661 -0.677348  5  3.0  5.0
</pre>
- boolean 으로, 결측치 확인하기. 




```python
pd.isna(df1)
```

<pre>
                A      B      C      D      F      E
2013-01-01  False  False  False  False  False  False
2013-01-02  False  False  False  False  False  False
2013-01-03  False  False  False  False  False  False
2013-01-04  False  False  False  False  False  False
</pre>
# Operation (연산) 



- Stats(통계)



```python
df
```

<pre>
                   A         B         C  D    F
2013-01-01  0.000000  0.000000  0.804306  5  NaN
2013-01-02 -0.947881  0.482789 -0.044766  5  1.0
2013-01-03  0.089794  0.407933 -0.081971  5  2.0
2013-01-04 -0.671818  1.295661 -0.677348  5  3.0
2013-01-05  0.519066 -1.204134  1.747446  5  4.0
2013-01-06 -0.528972 -0.741428  0.454718  5  5.0
</pre>

```python
df.mean()  # default 컬럼별
```

<pre>
A   -0.256635
B    0.040137
C    0.367064
D    5.000000
F    3.000000
dtype: float64
</pre>
- 축을 바꾸어서도 실행할 수 있다



```python
df.mean(1) # 인덱스별
```

<pre>
2013-01-01    1.451077
2013-01-02    1.098028
2013-01-03    1.483151
2013-01-04    1.589299
2013-01-05    2.012476
2013-01-06    1.836864
Freq: D, dtype: float64
</pre>

```python
s=pd.Series([1,3,5,np.nan,6,8],index=dates).shift(2)
print(s)
print(df)
```

<pre>
2013-01-01    NaN
2013-01-02    NaN
2013-01-03    1.0
2013-01-04    3.0
2013-01-05    5.0
2013-01-06    NaN
Freq: D, dtype: float64
                   A         B         C  D    F
2013-01-01  0.000000  0.000000  0.804306  5  NaN
2013-01-02 -0.947881  0.482789 -0.044766  5  1.0
2013-01-03  0.089794  0.407933 -0.081971  5  2.0
2013-01-04 -0.671818  1.295661 -0.677348  5  3.0
2013-01-05  0.519066 -1.204134  1.747446  5  4.0
2013-01-06 -0.528972 -0.741428  0.454718  5  5.0
</pre>

```python
df.sub(s,axis='index')  #  index 를 기준으로 했기 때문에, 값이 없는 부분은 nan 이 뜨고 값이 있는 부분은 그 부분 끼리 빼준다 broadcasting 적용 된 것
```

<pre>
                   A         B         C    D    F
2013-01-01       NaN       NaN       NaN  NaN  NaN
2013-01-02       NaN       NaN       NaN  NaN  NaN
2013-01-03 -0.910206 -0.592067 -1.081971  4.0  1.0
2013-01-04 -3.671818 -1.704339 -3.677348  2.0  0.0
2013-01-05 -4.480934 -6.204134 -3.252554  0.0 -1.0
2013-01-06       NaN       NaN       NaN  NaN  NaN
</pre>
# Apply(적용)



```python
print(df)
print(df.apply(np.cumsum)) # 축에 따라 밑으로 갈 수록 누적 합계
```

<pre>
                   A         B         C  D    F
2013-01-01  0.000000  0.000000  0.804306  5  NaN
2013-01-02 -0.947881  0.482789 -0.044766  5  1.0
2013-01-03  0.089794  0.407933 -0.081971  5  2.0
2013-01-04 -0.671818  1.295661 -0.677348  5  3.0
2013-01-05  0.519066 -1.204134  1.747446  5  4.0
2013-01-06 -0.528972 -0.741428  0.454718  5  5.0
                   A         B         C   D     F
2013-01-01  0.000000  0.000000  0.804306   5   NaN
2013-01-02 -0.947881  0.482789  0.759541  10   1.0
2013-01-03 -0.858087  0.890722  0.677570  15   3.0
2013-01-04 -1.529906  2.186383  0.000222  20   6.0
2013-01-05 -1.010840  0.982249  1.747668  25  10.0
2013-01-06 -1.539811  0.240821  2.202386  30  15.0
</pre>
# lambda

- def로 굳이 함수를 명명하지 않고 apply 함수 뒤에 lambda를 이용하는 방법도 있다. 



- 데이터프레임명.적용할 컬럼명.apply(lambda x:기능서술)



```python
print(df)
print(df.apply(lambda x:x.max()))  # 각열마다 최댓값 
```

<pre>
                   A         B         C  D    F
2013-01-01  0.000000  0.000000  0.804306  5  NaN
2013-01-02 -0.947881  0.482789 -0.044766  5  1.0
2013-01-03  0.089794  0.407933 -0.081971  5  2.0
2013-01-04 -0.671818  1.295661 -0.677348  5  3.0
2013-01-05  0.519066 -1.204134  1.747446  5  4.0
2013-01-06 -0.528972 -0.741428  0.454718  5  5.0
A    0.519066
B    1.295661
C    1.747446
D    5.000000
F    5.000000
dtype: float64
</pre>
# Histogramming(히스토그래밍) 



```python
s=pd.Series(np.random.randint(0,7,size=10))  #0부터 7사이의 값을 10개 랜덤
s
```

<pre>
0    2
1    6
2    2
3    3
4    6
5    1
6    1
7    1
8    3
9    1
dtype: int64
</pre>

```python
s.value_counts()   # 각 값의 갯수 카운팅
```

<pre>
1    4
2    2
6    2
3    2
dtype: int64
</pre>
# String Methods



```python
s = pd.Series(['A', 'B', 'C', 'Aaba', 'Baca', np.nan, 'CABA', 'dog', 'cat'])
s
```

<pre>
0       A
1       B
2       C
3    Aaba
4    Baca
5     NaN
6    CABA
7     dog
8     cat
dtype: object
</pre>

```python
s.str.lower()  #  s의 문자열을 다 소문자를 써라.
```

<pre>
0       a
1       b
2       c
3    aaba
4    baca
5     NaN
6    caba
7     dog
8     cat
dtype: object
</pre>
# Merge

- Concat(연결) 




```python
df=pd.DataFrame(np.random.randn(10,4))  #10행 4열 random 으로 만들어라
df
```

<pre>
          0         1         2         3
0  1.262212  0.955071  0.203384  0.508407
1  0.512366  2.174993 -1.555680  0.617319
2  0.586218  0.729675 -0.328818 -1.401425
3 -1.025362  0.487188 -0.605979 -0.655267
4  1.446434  0.578147  0.249187  0.808614
5  1.827873  1.416959 -2.200127 -0.075029
6 -1.802936 -0.342006  0.971964  0.316691
7 -0.298966  1.571829 -1.589146 -0.240107
8  1.457950 -0.184842 -1.340462 -0.566541
9 -1.402115  1.613607 -0.019760 -1.038753
</pre>

```python
pices=[df[:3],df[3:7],df[7:]]
pices
```

<pre>
[          0         1         2         3
 0  1.262212  0.955071  0.203384  0.508407
 1  0.512366  2.174993 -1.555680  0.617319
 2  0.586218  0.729675 -0.328818 -1.401425,
           0         1         2         3
 3 -1.025362  0.487188 -0.605979 -0.655267
 4  1.446434  0.578147  0.249187  0.808614
 5  1.827873  1.416959 -2.200127 -0.075029
 6 -1.802936 -0.342006  0.971964  0.316691,
           0         1         2         3
 7 -0.298966  1.571829 -1.589146 -0.240107
 8  1.457950 -0.184842 -1.340462 -0.566541
 9 -1.402115  1.613607 -0.019760 -1.038753]
</pre>

```python
pd.concat(pices)  # 축에따라 위 아래 붙이는 함수.  3개의 리스트로 이루어져있던 함수를 합침.
```

<pre>
          0         1         2         3
0  1.262212  0.955071  0.203384  0.508407
1  0.512366  2.174993 -1.555680  0.617319
2  0.586218  0.729675 -0.328818 -1.401425
3 -1.025362  0.487188 -0.605979 -0.655267
4  1.446434  0.578147  0.249187  0.808614
5  1.827873  1.416959 -2.200127 -0.075029
6 -1.802936 -0.342006  0.971964  0.316691
7 -0.298966  1.571829 -1.589146 -0.240107
8  1.457950 -0.184842 -1.340462 -0.566541
9 -1.402115  1.613607 -0.019760 -1.038753
</pre>
- join(결합)

- SQL 방식으로 병합합니다.



```python
left=pd.DataFrame({'key':['foo','foo'],'lval':[1,2]})
right=pd.DataFrame({'key':['foo','foo'],'lval':[4,5]})
print(left)
print(right)
```

<pre>
   key  lval
0  foo     1
1  foo     2
   key  lval
0  foo     4
1  foo     5
</pre>

```python
pd.merge(left,right,on='key')  #on => 기준 컬럼명을 써준다. 
```

<pre>
   key  lval_x  lval_y
0  foo       1       4
1  foo       1       5
2  foo       2       4
3  foo       2       5
</pre>

```python
left = pd.DataFrame({'key' : ['foo', 'bar'], 'lval' : [1, 2]})
right = pd.DataFrame({'key': ['foo', 'bar'], 'rval': [4, 5]})
print(left)
print(right)
print(pd.merge(left, right, on= 'key'))
```

<pre>
   key  lval
0  foo     1
1  bar     2
   key  rval
0  foo     4
1  bar     5
   key  lval  rval
0  foo     1     4
1  bar     2     5
</pre>
- Append(추가)



```python
df = pd.DataFrame(np.random.randn(8, 4), columns=['A', 'B', 'C', 'D'])
df
```

<pre>
          A         B         C         D
0 -1.956503  0.016695 -1.376558  0.882448
1 -3.313167 -0.644514  0.439943 -2.580286
2  0.575209  0.129929  1.329659 -0.101877
3  0.332593 -0.398031  1.001786  0.371959
4 -0.305303 -0.695755 -0.817616  0.965844
5  0.599091 -0.984070 -1.422782 -2.028921
6  1.295195 -0.209816  2.010686  0.409705
7  0.268063  2.963411  1.338692 -0.083000
</pre>

```python
s=df.iloc[3]
s
```

<pre>
A    0.332593
B   -0.398031
C    1.001786
D    0.371959
Name: 3, dtype: float64
</pre>

```python
print(df)
print(df.append(s,ignore_index=True))
```

<pre>
          A         B         C         D
0 -1.956503  0.016695 -1.376558  0.882448
1 -3.313167 -0.644514  0.439943 -2.580286
2  0.575209  0.129929  1.329659 -0.101877
3  0.332593 -0.398031  1.001786  0.371959
4 -0.305303 -0.695755 -0.817616  0.965844
5  0.599091 -0.984070 -1.422782 -2.028921
6  1.295195 -0.209816  2.010686  0.409705
7  0.268063  2.963411  1.338692 -0.083000
          A         B         C         D
0 -1.956503  0.016695 -1.376558  0.882448
1 -3.313167 -0.644514  0.439943 -2.580286
2  0.575209  0.129929  1.329659 -0.101877
3  0.332593 -0.398031  1.001786  0.371959
4 -0.305303 -0.695755 -0.817616  0.965844
5  0.599091 -0.984070 -1.422782 -2.028921
6  1.295195 -0.209816  2.010686  0.409705
7  0.268063  2.963411  1.338692 -0.083000
8  0.332593 -0.398031  1.001786  0.371959
</pre>
# Grouping(그룹화)

- 그룹화는 다음 단계중 하나 이상을 포함하는 과정을 가리킵니다. 

 + 몇몇 기준에 따라 여러그룹으로 데이터를 분할(splitting)

 + 각 그룹에 독립적으로 함수를 적용(applying)

 + 결과물들을 하나의 데이터 구조로 결합(combining)

 



```python
df = pd.DataFrame(
    {
        'A' : ['foo', 'bar', 'foo', 'bar', 'foo', 'bar', 'foo', 'foo'],
        'B' : ['one', 'one', 'two', 'three', 'two', 'two', 'one', 'three'],
        'C' : np.random.randn(8),
        'D' : np.random.randn(8)
    })
df
```

<pre>
     A      B         C         D
0  foo    one  2.320590  1.009107
1  bar    one -0.273917 -0.749687
2  foo    two -0.817982 -0.413826
3  bar  three  0.810967  0.348991
4  foo    two  1.299073 -0.947616
5  bar    two  1.743033 -1.497056
6  foo    one  0.626893 -0.236820
7  foo  three  2.109443  0.383633
</pre>

```python
print(df.groupby('A').sum())  # A열을 기준으로 나머지 열의 값 합계 , B열은 문자열이라 제외

print(df.groupby(['A','B']).sum())  #A-B기준으로 합계
```

<pre>
            C         D
A                      
bar  2.280084 -1.897753
foo  5.538016 -0.205523
                  C         D
A   B                        
bar one   -0.273917 -0.749687
    three  0.810967  0.348991
    two    1.743033 -1.497056
foo one    2.947482  0.772287
    three  2.109443  0.383633
    two    0.481090 -1.361442
</pre>
#Reshaping (변형) 


- Stack(스택)



```python
tuples=list(zip(*[]))
```
