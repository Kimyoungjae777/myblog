---
title: "SQLD 준비"
author: "Young Jae Kim"
date: '2022-08-06'
output:
  html_document:
    keep_md: true
categories: 
- Development
- DataBase
tags:
- Development
- DataBase

---

# SQLD

# 1.데이터 모델링

- 데이터 모델링은 현실 세계를 데이터베이스로 표현하기 위해서 추상화한다.
- 데이터 모델링을 하기 위해서는 고객과의 의사소통을 위해 업무 프로세스를 이해해야 한다.
- 고객의 업무 프로세스를 이해한 후 데이터 모델링 표기법을 사용해서 모델링을 한다.
- 고객의 업무 프로세스를 이해한 후 데이터 모델링 표기법을 사용해서 모델링을 한다.
- 데이터 모델링은 고객의 업무 프로새스를 추상화하고, 소프트웨어를 분석,설계 하면서 점점 더 상세해진다.
- 데이터 모델링은 고객의 비즈니스 프로세스를 이해하고 비즈니스 프로세스의 규칙을 정의한다. 정의된 비즈니스 규칙을 데이터 모델로 표현한다.

### 데이터 모델링의 특징

- 데이터 모델링은 추상화 해야한다 →추상화는 공통적인 특징을 찾고 간략하게 표현한다
- 데이터 모델링은 단순화 해야한다 →복잡한 문제를 피하고 누구나 이해할 수 있게 표현한다
- 데이터 모델링은 명확 해야한다→ 의미적 해석이 모호하지 않고 명확하게 해석되어야 한다.

### 데이터 모델링 단계

1)개념적 모델링 

- 고객의 비즈니스 프로세스를 분석하고 업무 전체에 대해서 데이터 모델링을 수행한다.
- 복잡하게 표현하지 않고 중요한 부분을 위주로 모델링하는 단계이다
- 업무적 관점에서 모델링하며 기술적인 용어는 가급적 사용하지 않는다.
- 엔터티와 속성을 도출하고, 개념적 ERD(Entity Relationship Digram)을 작성한다.

2)논리적 모델링

- 개념적 모델링을 논리적 모델링으로 변환하는 작업이다
- 식별자를 도출하고 필요한 모든 릴레이션을 정의한다
- 정규화를 수행해서 데이터 모델의 독립성을 확보한다

3)물리적 모델링

- 데이터베이스를 실제 구축한다. 즉 테이블,인덱스,함수 등을 생성한다
- 성능,보안,가용성을 고려해서 구축한다

    개념적모델링- 전사적 관점에서 기업의 데이터를 모델링한다

                 - 추상화 수준이 가장 높은 수준의 모델링이다. 

                 - 계층형 데이터모델,네트워크 모델, 관계형 모델에 관계없이 업무 측면에서 모델링. 

논리적 모델링-특정 데이터베이스 모델에 종속한다

                       -식별자를 정의하고 관계 속성 등을 모두 표현한다

                       -정규화를 통해서 재사용성을 높인다

물리적 모델링 - 구축할 데이터베이스 관리시스템에 테이블,인덱스 등을 생성하는 단계이다

                        - 성능,보안,가용성 등을 고려하여 데이터베이스를 구축한다.

### 데이터 모델링 관점

데이터 - 비즈니스 프로세스에서 사용되는 데이터를 의미한다

            - 구조분석,정적분석

프로세스 -비즈니스 프로세스에서 수행하는 작업을 의미한다

                - 시나리오 분석,도메인 분석, 동적 분석

데이터와 프로세스- 프로세스와 데이터 간의 관계를 의미한다

                              - CRUD(Create,Read,Update,Delete) 분석

 

# ERD

1.엔터티를 도출하고 그린다

- 업무에서 관리해야 하는 집을 도출한다.

2.엔터티를 배치한다

- 엔터티를 도출한 후 엔터티를 배치한다.
- 중요한 엔터티를 왼쪽 상단에 배치한다

     3.엔터티 간의 관계를 설정한다

     4.관계명을 서술한다.

     -엔터티 간의 어떤 행위나 존재가 있는지 표현한다. 

     5.관계 참여도를 표현한다

- 관계 참여도는 한 개의 엔터티와 다른 엔터티 간의 참여하는 관계 수를 의미한다.
- 즉,”고객이 여러개의 계좌를 개설할 수 있다” 와 같은 의미를 표현하는 것이다.

6.관계의 필수 여부를 표현한다

- 필수는 반드시 존재해야 하는 것이다.
- 예를들어 “모든 고객은 반드시 하나의 계좌를 개설해야 한다.” 와 같은 의미를 표현한다.

### ERD 작성시 고려사항

- 중요한 엔터티를 가급적 왼쪽 상단에 배치한다
- ERD는 이해가 쉬워야 하고 너무 복잡하지 않아야한다.

### 데이터 모델링 고려사항

(1)데이터 모델의 독립성

- 독립성이 확보된 모델은  고객의 업무 변화에 능동적으로 대응할 수 있다.
- 독립성을 확보하기 위해서는 중복된 데이터를 제거해야한다.
- 데이터 중복을 제거하는 방법이 바로 정규화이다.

(2)고객 요구사항의 표현

- 데이터 모델링으로  고객과 데이터 모델러 간에 의사소통을 할 수 있어야 하므로, 고객의 요구 사항을 간결하고 명확하게 표현해야 한다.

(3)데이터 품질 확보

- 데이터베이스 구축 시에 데이터 표준을 정의하고 표준 준수율을 관리해야 한다.
- 데이터 표준을 확보해야 데이터 품질을 향상 시킬수 있다.

## 3층 스키마(3-LEVEL Schema)

- 사용자,설계자 개발자가 데이터베이스를 보는 관점에 따라 데이터베이스를 기술하고 이들 간의 관계를 정의한 ANSI 표준이다
- 3층 스키마는 데이터베이스의 독립성을 확보하기 위한 방법이다.
- 데이터의 독립성을 확보하면 데이터 복잡도 감소, 데이터 중복 제거,사용자 요구사항 변경에 따른 대응력 향상, 관리 및 유지보수 비용 절감 등의 장점을 갖는다.
- 3단계 계층으로 분리해서 독립성을 확보하는 방법으로 각 계층을 뷰라고도 한다.

### 3층 스키마의 독립성

- 논리적 독립성- 개념 스키마가 변경되더라도 외부 스키마가 영향을 받지 않는 것이다
- 물리적 독립성- 내부스키마가 변경되더라도, 개념 스키마가 영향을 받지 않는것이다.

### 외부스키마

-사용자 관점, 업무상 관련이 있는 데이터 접근이다.

-관련 데이터베이스의 뷰를 표시한다.

-응용프로그램이 접근하는 데이터베이스를 정의한다.

### 개념스키마

-설계자 관점,사용자 전체집단의 데이터베이스 구조이다

-전체 데이터베이스 내의 규칙과 구조를 표현한다.

-통합 데이터베이스 구조이다.

### 내부스키마

-개발자관점,데이터베이스의 물리적 저장구조이다.

-데이터 저장구조,레코드 구조, 필드정의,인덱스 등을 의미한다. 

             

 

# 엔터티

- 엔터티는 업무에서 관리해야 하는 데이터 집합을 의미하며,
- 엔터티는 개념,사건,장소 등의 명사이다.

### 엔터티 도출

- 엔터티는 고객의 비즈니스 프로세스에서 관리되어야 하는 정보를  추출해야 한다.
- 다음의 예를 통해 업무에서 관리해야 하는 엔터티를 도출해보자.

ex) 1.고객이 회원가입을 한다. 회원으로 가입할 때는 회원ID,패스워드,이름,주소,전화번호 등을 입력해야한다.

2.회원으로 가입하기 위해서는 반드시 하나의 계좌를 개설해야 한다.

3.고객은 계좌를 여러 개 개설할수 있다.

4.계좌를 개설할때는 계좌번호,계좌명,예수금,계좌개설,계좌담당자가 입력된다 . 

- 위의 시나리오 에서 엔터티를 도출하면 다음과 같다.

![Untitled](images/SQLD/0.png)

### 엔터티의 특징

식별자- 엔터티는 유일한 식별자가 있어야 한다. ex)회원 id,계좌번호

인스턴스집합- 2개 이상의 인스턴스가 있어야한다.

속성-엔터티는 반드시 속성을 가지고 있다. ex)고객 엔터티에 회원id,패스워드,이름,주소,전화번호

관계- 엔터티는 다른 엔터티와 최소한 한 개 이상의 관계가 있어야한다. ex)고객은 계좌를 개설한다. 

업무- 엔터티는 업무에서 관리되어야하는 집합이다.

### 릴레이션과 테이블, 인스턴스

- 릴레이션과 테이블은 같은 의미라고 해석하면 된다. 릴레이션에 기본키 및 제약조건을 설정하면 테이블이 된다.
- 단 Relationship은 릴레이션 간의 관계를 의미한다.
- 인스턴스는 릴레이션이 가질 수 있는 값을 의미한다. 간단하게 생각하면 행의 수를 의미한다.(인덱스)

### 엔터티의 종류

- 엔터티의 종류는 유형과 무형에 따른 종류,엔터티가 발생하는 시점에 따른 종류로 나누어 진다.
- 엔터티를 유형과 무형으로 분류하는 기준은 물리적 형태의 존재여부다 .

### 유형과 무형에 따른 엔터티 종류

- 유형 엔터티:업무에서 도출되며 지속적으로 사용되는 엔터티이다. ex)고객,강사,사원 등
- 개념 엔터티:유형 엔터티는 물리적형태가 있지만, 개념 엔터티는 물리적 형태가 없다. ex)거래소,종목,코스닥 종목
- 사건 엔터티:비즈니스 프로세스를 실행하면서 생성되는 엔터티이다. ex)주문,체결,취소주문,수수료 청구 등

### 발생 시점에 따른 엔터티종류

- 기본엔터티: 키 엔터티라고도 한다, 다른 엔터티로부터 영향을 받지 않고 독립적으로 생성되는 엔터티이다.
- 중심엔터티:기본 엔터티와 행위 엔터티 간의 중간에 있는 것이다. 즉 기본엔터티로부터 발생되고 , 행위 엔터티를 생성하는 것이다. ex)계좌,주문,취소,체결 등
- 행위 엔터티:2개 이상의 엔터티로 부터 발생된다. ex)주문이력,체결이력 등

## 속성

- 속성이라는 것은 업무에서 필요한 정보인 엔터티가 가지는 항목이다.
- 속성은 더 이상 분리되지 않는 단위로, 업무에 필요한 데이터를 저장할 수 있다.
- 인스턴스의 구성요소이고 의미적으로 더 이상 분해되지 않는다.

### 속성의 특징과 종류

(1) 속성의 특징 

- 속성은 업무에서 관리되는 정보이다.
- 속성은 하나의 값만 가진다.
- 주식별자에게 함수적으로 종속된다, 즉 기본키가 변경되면 속성의 값도 변경된다는 것이다.

(2) 속성의 종류

### 분해 여부에 다른 속성의 종류

- 단일속성:하나의 의미로 구성된 것으로 회원 id , 이름 등이다.
- 복합속성: 여러 개의 의미가 있는 것으로 대표적으로 주소가 있다,주소는 시,군,동 등으로 분해될 수 있다.
- 다중값 속성- 속성에 여러 개의 값을 가질 수 있는것으로 예를 들어 상품 리스트가 있다.,다중값 속성은 엔터티로 분해된다.

### 특성에 따른 속성의종류

- 기본속성:비즈니스 프로세스에서 도출되는 본래의 속성이다. ex)회원id,이름,계좌번호,주문 일자 등
- 설계속성: 데이터 모델링 과정에서 발생되는 속성이다. , 유일한 값을 부여한다 ex)상품코드,지점코드 등
- 파생속성:다른 속성에 의해서 만들어지는속성이다

### 도메인

- 도메인은 속성이 가질 수 있는 값의 범위이다. ex)성별이라는 속성의 도메인은 남자와 여자이다.

### 관계

- 관계는 엔터티 간의 관련성을 의미하며 존재관계와 행위관계로 분류된다.
- 존재관계는 두 개의 엔터티가 존재 여부의 관계가 있는 것이고,행위 관계는 두 개의 엔터티가 어떤 행위에 의한 관련성이 있는것이다.

### 관계의 종류

(1) 존재관계 

- 존재 관계는 엔터티 간의 상태를 의미한다. 예를들어 고객이 은행에 회원가입을 하면, 관리점이 할당되고, 그 할당된 관리점에서 고객을 관리한다.

(2) 행위관계

- 행위 관계는 엔터티 간에 어떤 행위가 있는 것으로, 계좌를 사용해서 주문을 발주하는 관계가 만들어진다.
- 예를들어 증권회사는 계좌를 개설하고 주문을 발주하는 것이다

![Untitled](images/SQLD/1.png)

### 관계차수

- 관계 차수는 두 개의 엔터티 간에 관계에서 참여하는 수를 의미한다.
- 예를들어 한명의 고객은 여러 개의 계좌를 개설할 수 있다. 이러한 경우는 1대N관계가 된다.

![Untitled](images/SQLD/2.png)

### 1대1 관계

- 1대1 관계는 완전 1대1관계와 선택적 1대1 관계가 있다.
- 다음의 예는 선택적 1대1 관계를 표현한것이다. 한명의 고객은 하나의 고객등급이부여되거나 고객 등급이 없을수도 있다.

![Untitled](images/SQLD/3.png)

**완전 1대1**:하나의 엔터티에 관계되는 엔터티의 관계가 하나인 경우로,반드시 존재해야한다.

**선택적 1대1:** 하나의 엔터티에 관계되는 엔터티의 관계가 하나이거나 없을 수도 있다.

### 1대 N관계

- 1대N 관계는 엔터티에 행이 하나 있을 때 다른 엔터티의 값이 여러 개 있는 관계이다.
- 예를들어 고객은 여러개의 계좌를 가질 수 있다.

![Untitled](images/SQLD/4.png)

### M대N관계

- M대N관계는 두 개 엔터티가 서로 여러개의 관계를 가지고 있는 것이다.
- 예를들어 한명의 학생이 여러개의 과목을 수강할 수 있다. 바낻로 한 개의 과목은 여러명의 학생이 수강한다, 그래서 M대N관계가 발생한다.
- 관계형 데이터베이스에서 M대N관계의 조인은 카테시안 곱이 발생한다. 그래서 M대N관계를

1대N, N대 1로 해소해야한다.

### 카테시안 곱 (곱집합)

- 각 릴레이션에 존재하는 모든 데이터를 조합하여 연산하는 것을 말한다.

### 필수적 관계와 선택적관계

- 필수적 관계: 반드시 하나가 있어야 하는 관계이다. EX) 고객이 반드시 있어야 계좌를 개설할 수 있다.
- 선택적 관계: 1.없을수도 있는 관계이다 2. 고객은 있지만, 계좌가 없을 수도 있다면 선택적 관계가 된다.

### 식별관계와 비식별 관계

### 식별관계

- 고객과 계좌 엔터티에서 고객은  독립적으로 존재할 수 있는 강한개체 이다.
- 강한 개체는 어떤 다른 엔터티에게 의존하지 않고 독립적으로 존재한다.
- 강한 개체는 다른 엔터티와 관계를 가질 때 다른 엔터티에게 기본키를 공유한다.
- 강한 개체는 식별관계로 표현된다.
- 즉, 식별 관계란 고객 엔터티의 기본키인 회원 ID를 계좌 엔터티의 기본키의 하나로 공유하는 것이다.
- 강한 개체의 기본키 값이 변경되면 식별관계(기본키를 공유받은)에 있는 엔터티의 값도 변경 된다.
- 여기서 계좌 엔터티는 약한 개체가 된다.
- 

### 비식별 관계

- 비식별관계는 강한 개체의 기본키를 다른 엔터티의 기본키가 아닌 일반 칼럼으로 관계를 가지는 것이다.
- 예를 들어 관리점 엔터티의 기본키는 지점코드이고 괙 엔터티와 비식별 관계를 가지고 있다. 즉, 지점코드는 고객 엔터티의 기본키가 아닌 일반칼럼으로 참조된다.  비식별 관계는 점선으로 표현한다.

### 엔터티 식별자

### 주식별자 (기본키, Primary key)

- 최소성:주식별자는 최소성을 만족하는 키이다.→ 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성.
- 대표성:주식별자는 엔터티를 대표할 수 있어야 한다.
- 유일성:주식별자는 엔터티의 인스턴스를 유일하게 식별한다.
- 불변성:주식별자는 자주 변경되지 않아야 한다.

키의 종류 

기본키:후보키 중에서 엔터티를 대표할 수 있는 키이다.

후보키:후보키는 최소성과 유일성을 만족하는 키이다.(최소성 o 유일성 o)

슈퍼키:슈퍼키는 유일성은 만족하지만 최소성을 만족하지 않는 키이다. (유일성 o 최소성 x)

대체키:대체키는 여러 개의 후보키 중에서 기본키를 선정하고 남은 키이다. ( 기본키를 선정하고 남은 키)

외래키:하나 혹은 다수의 다른 테이블의 기본 키 필드를 가리키는 것으로 참조 무결성을 확인하기 위해 사용되는 키이다. , 즉 허용된 데이터값만 데이터베이스에 저장하기 위해서 사용한다. 

cf) 참조무결성:  하나의 기본키를 외래키로 공유하고 있다면 기본키의 값이 달라지면 외래키의 값도 같이 변하는 것,

### 식별자의 종류

- 식별자는 대표성, 생성여부,속성의 수 , 대체 여부로 분류된다.

(1) 식별자의 대표성

- 주식별자는 엔터티를 대표할 수 있는 식별자이다. 예를들어 회원 id 는 고객 엔터티에 주식별자가 된다.

주식별자-유일성과 최소성을 만족하면서 엔터티를 대표하는 식별자 이다.

         -다른 엔터티와 참조 관계로 연결될 수 있다.

보조식별자- 유일성과 최소성은 만족하지만 대표성을 만족하지 못하는 식별자이다. 

(2)생성 여부

내부 식별자-내부식별자는 엔터티 내부에서 스스로 생성되는 식별자이다. 

ex)부서코드,주문번호,종목코드 등 

외부 식별자-다른 엔터티와의 관계로 인하여 만들어지는 식별자이다. 

ex)계좌 엔터티에 회원 id

(3)속성의 수

단일 식별자- 하나의 속성으로 구성된다 

ex)고객 엔터티에 회원id

복합 식별자-두 개 이상의 속성으로 구성된다.

(4)대체 여부

본질 식별자 - 비즈니스 프로세스에서 만들어지는 식별자이다.

인조 식별자- 인위적으로 만들어지는 식별자이다. 

### 인조 식별자

- 인조 식별자는 후보 식별자 중에서 주식별자로 선정할 것이 없거나, 주식별자가 너무 많은 칼럼으로 되어 있는경우에 사용된다 ,즉 순서번호를 사용해서 식별자를 만드는것이다.


### 정규화

- 정규화는 데이터의 일관성,최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법이며 데이터를 분해하는 과정이다
- 정규화는 데이터 중복을 제거하고 데이터 모델의 독립성을 확보하기 위한 방법이다.
- 정규화는 테이블을 분해해서 데이터 중복을 제거하기 때문에 데이터 모델의 유연성을 높힌다.
- 정규화를 수행하면 비즈니스에 변화가 발생하여도 데이터 모델의 변경을 최소화할 수 있다.
- 정규화는 제1정규화부터 제5정규화까지 있지만, 실질적으로는 제3정규화까지만 수행한다.

![Untitled](images/SQLD/7.png)

- 위의 테이블은 정규화를 수행하지 않은 것으로, 부서테이블과 직원 테이블을 하나로 합쳐 둔 것이다. 만약 위의 테이블에서 새로운 직원이 추가되는 경우 부서 정보가 없으면 부서코드를 임의의 값으로 넣어야한다. 즉, 불필요한 정보가 같이 추가되는 것이다. 또한 새로운 “총무부”가 추가되어야 할 경우 사원 정보가 없기 때문에 임의의 값으로 사원번호를 입력하거나 추가할 수 없게 된다. 이러한 문제를 이상현상 이라고한다.
- 위와 같은 문제를 해결하기 위해서는 테이블을 분해해야한다.

![Untitled](images/SQLD/8.png)

 

- 정규화된 모델은 테이블이 분해된다. 테이블이 분해되면 직원테이블과 부서테이블 간에 부서코드로 조인을 수행하여 하나의 합집합으로 만들수 있다.
- 정규화를 수행하면 불필요한 데이터를 입력하지 않아도 되기 때문에 중복데이터가 제거된다.

### 함수적 종속성

![Untitled](images/SQLD/9.png)

### 제1 정규화,제2 정규화,제3 정규화

- 제 1 정규화:각각의 컬럼들을 원자화 하여라 ( 값들을 하나씩 가지게 하여라)→1.속성의 원자성을 확보한다 2.기본키를 설정한다

![Untitled](images/SQLD/10.png)

### 제2 정규화

- 기본키가 2개 이상의 속성으로 이루어진 경우, 부분 함수 종속성을 제거(분해) 한다.
- 같은 테이블 안에서 부분함수적 종속성이 발생하면 안된다. 이를 제거해야한다 → 동시에 중복도 제거됨,부분함수적 종속성이 발생하면 안되는거지 하나의 테이블 안에서 프라이머리 키에 의해서 함수의 종속성은 발생해야하는 것이다.

![Untitled](images/SQLD/11.png)

### 제3 정규화

- 기본키를 제외한 칼럼 간에 종속성을 제거한다.
- 즉, 이행 함수 종속성을 제거한다.

![Untitled](images/SQLD/12.png)

### 정규화의 성능

1.정규화의 문제점

- 정규화는 데이터 조회 시에 조인을 유발하기 때문에 cpu와 메모리를 많이 사용한다.
- 정규화의 문제점을 해결하기 위해서 반정규화를 하여 하나의 테이블에 저장한다면 조인을 통한 성능 저하는 해결될 것이다.
- 하지만 반정규화로 너무 많은 칼럼이 추가되면 한 개 행의 크기가 데이터 베이스 관리 시스템의 입출력 단위인 블록의 크기를 넘어서게 된다.
- 그렇게 되면 한 개의 행을 읽기 위해서 여러 개의 블록을 읽어야 한다. 한행을 읽기 위해서 여러 개의 블록을 읽게 되면 디스크 입출력이 증가하기 때문에 성능이 떨어지게된다. 반 정규화는 이러한 문제점을 유발할수 있다.

### 반정규화

- 데이터베이스 성능 향상을 위하여, 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법이다.
- 반정규화는 조회 속도를 향상하지만, 데이터 모델의 유연성은 낮아진다.

### 반정규화를 수행하는 경우

- 정규화를 충실하면, 종속성 ,활용성은 향상되지만 수행속도가 느려지는 경우
- 다량의 범위를 자주 처리해야 하는 경우
- 특정 범위의 데이터만 자주 처리하는경우
- 요약/집계 정보가 자주 요구되는 경우

### 반정규화 절차

- 대상 조사 및 검토:데이터 처리 범위, 통계성 등을 확인해서 반정규화 대상을 조사한다.
- 다른 방법검토:반정규화를 수행하기 전에 다른 방법이 있는지 검토한다, 예를들어 클러스터링 뷰,인덱스 튜닝,응용 프로그램,파티션 등을 검토한다.
- 반정규화 수행:테이블,속성,관계 등을 반정규화 한다

### 반정규화 기법

### (1) 계산된 칼럼 추가

- 배치 프로그램으로 총판매액,평균잔고,계좌평가 등을 미리 계산하고, 그 결과를 특정 칼럼에 추가한다.

### (2)테이블 수직 분할

- 하나의 테이블을 두 개 이상의 테이블로 분할한다. 즉,칼럼을 분할하여 새로운 테이블을 만드는 것이다.

### (3)테이블 수평 분할

- 하나의 테이블에 있는 값을 기준으로 테이블을 분할하는 방법이다.

### 파티션 기법

- 데이터베이스에서 파티션을 사용하여 테이블을 분할할 수 있다. 파티션을 사용하면 논리적으로는 하나의 테이블이지만, 여러 개의 데이터 파일에 분산되어 저장한다.
- Range partition:데이터 값의 범위를 기준으로 파티션을 수행한다
- list partition:특정한 값을 지정하여 파티션을 수행한다
- hash partition:해시 함수를 적용하여 파티션을 수행한다.
- Composite Partiton:범위와 해시를 복합적으로 사용하여 파티션을 수행한다.

### 파티션 테이블의 장점

- 데이터 조회 시에 엑세스 범위가 줄어들기 때문에 성능이 향상된다.
- 데이터가 분할되어 있기 때문에 input/output 성능이 향상된다.
- 각 파티션을 독립적으로 백업 및 복구가 가능하다

### (4) 테이블 병합

- 1대1관계의 테이블을 하나의 테이블로 병합해서 성능을 향상시킨다.
- 1대N 관계의 테이블을 병합하여 성능을 향상시킨다. 하지만 많은 양의 데이터 중복이 발생한다.
- 슈퍼 타입과 서브타입 관계가 발생하면 테이블 통합하여 성능을 향상시킨다.

### SUPER TYPE 과 SUB TYPE

- 고객 엔터티는 개인고객과 법인고객으로 분류된다. 이때 고객 엔티티는 슈퍼타입이고, 개인고객과 법인고객은 서브타입이 된다 (대분류 소분류 관계)
- 즉, 부모와 자식 간의 관계가 나타난다,
- 슈퍼타입과 서브 타입의 관계는 배타적 관계와 포괄적 관계가 있는데 , 베타적 관계는 고객이 개인고객이거나 법인고객인 경우를 의미한다. 포괄적 관계는 고객이 개인고객일 수도 있고 법인 고객일 수도 있다.

### 슈퍼 타입 및 서브 타입 변환 방법

- ONE TO ONE TYPE -슈펴타입과 서브타입을 개별 테이블로 도출한다.
    
                                   -테이블의 수가 많아서 조인이 많이 발생하고 관리가 어렵다.
    
- Plus type -슈퍼타입과 서브 타입 테이블로 도출한다

                      -조인이 발생하고 관리가 어렵다

- single type-슈퍼 타입과 서브타입을 하나의 테이블로 도출한다.

                        -조인 성능이 좋고 관리가 편리하지만, 입출력 성능이 나쁘다. 

### 분산 데이터베이스

### 데이터베이스 구조

- 데이터베이스 시스템 구축 시에 한 대의 물리적 시스템에 데이터베이스 관리 시스템을 설치하고 여러명의 사용자가 데이터베이스 관리 시스템에 접속하여 데이터베이스를 사용하는 구조를

      중앙집중형 데이터베이스 라고한다 

- 또한 물리적으로 떨어진 데이터베이스에 네트워크로 연결하여 단일 데이터베이스 이미지를 보여주고 분산된 작업처리를 수행하는 데이터베이스를 분산 데이터베이스 라고 한다

### 분산 데이터베이스의 투명성

- 분산 데이터베이스를 사용하는 고객은 시스템이 네트워크로 분산되어 있는지의 여부를 인식하지 못하면서, 자신만의 데이터베이스를 사용하는 것처럼 사용할 수 있다. 이처럼, 데이터베이스는 투명성을 제공해야 한다.
- 투명성은 분산 데이터베이스에서 중요한 요소이며, 투명성의 종류에는 분할,위치,지역사상,중복,장애 및 병행 투명성이 있다.

### 분산 데이터베이스의 투명성 종류

1.분할투명성: -고객은 하나의 논리적 릴레이션이  여러 단면으로 분할되어 각 단편의 사본이 여러 시스템에 저장되어 있음을 인식할 필요가 없다

2.위치투명성:-고객이 사용하려는 데이터의 저장 장소를 명시할 필요가 없다

                      -고객은 데이터가 어느 위치에 있더라도 동일한 명령을 사용하여 데이터에 접근할 수

                        있어야한다.         

3.지역사상 투명성 -지역 DBMS와 물적 데이터베이스 사이의 사상이 보장됨에 따라 각 지역 시스템    이름과 무관한 이름이 사용 가능하다

4.중복투명성-데이터베이스 객체가 여러 시스템에 중복되어 존재함에도 고객과는 무관하게 데이터의 일관성이 유지된다

5.장애투명성-데이터베이스가 분산되어 있는 각 지역의 시스템이나 통신망에 이상이 발생해도, 데이터의 무결성은 보장된다.       

6.병행투명성 -여러 고객의 응용 프로그램이 동시에 분산 데이터베이스에 대한 트랜잭션을 수행하는 경우에도 결과에 이상이 없다

### 분산 데이터베이스 설계방식

- 분산 데이터베이스의 구축 방법에는 상향식 설계 방식과 하향식 설계 방식 2가지가 있다.

(1) 상향식 설계방식 

- 지역 스키마 작성 후 전역스키마를 작성하여 분산 데이터베이스를 구축한다.

(2)하향식 설계방식

- 전역 스키마 작성 후 해당 지역 사상 스키마를 작성하여 분산 데이터베이스를 구축한다.

![Untitled](images/SQLD/13.png)

- 분산 데이터베이스를 하향식 접근 방식으로 구축한다는 것은 기업 전체의 전사 데이터 모델을 수렴하여 전역 스키마를 생성하고,  그 다음 각 지역별로 지역 스키마를 생성하여 분산 데이터베이스를 구축 하는 것이다. 상향식 접근 방식은 지역별로 데이터베이스를 구축한 후에 전역 스키마로 통합하는 것이다.
- 분산 데이터베이스를 구축하거나 운영할 때 동일한 데이터베이스 관리 시스템으로 분산 데이터베이스를 구축하는 것은 크게 어렵지 않다. 하지만 기업에 여러 종류의 데이터베이스 관리 시스템이 있으면 이기종 데이터베이스 관리시스템으로 연동해야 한다. 이기종 데이터베이스 시스템으로 연동하기 위해서는 데이터베이스 미들웨어 (ODBC,JDBC)를 사용해야 한다.

### 분산 데이터베이스 장점과 단점

- 장점:1.데이터베이스의 신뢰성과 가용성이 높다. 2.분산 데이터베이스가 병렬 처리를 수행하기 때문에 빠른 응답이 가능하다. 3.분산 데이터베이스를 추가하여 시스템 용량 확장이 쉽다
- 단점: 1.데이터베이스가 여러 네트워크를 통해서 분리되어 있기 때문에 관리와 통제가 어렵다

                2.보안관리가 어렵다. 

                3.데이터 무결성 관리가 어렵다

                4.데이터베이스 설계가 복잡하다. 

# 관계형 데이터베이스

(1) 관계형 데이터베이스의 등장 

- 관계형 데이터베이스는 릴레이션과 릴레이션의 조인연산을 통해서 합집합,교집합,차집합 등을 만들 수 있다.
- 현재 기업에서 가장 많이 사용하는 데이터베이스로 Oracle,MS-SQL,MYSQL,SYBASE 등의 다양한 데이터베이스 관리 시스템이 있다

### 데이터베이스와 데이터베이스 관리 시스템의 차이점

- 데이터베이스는 데이터를 어떠한 형태의 자료구조로 사용하느냐에 따라서 나누어진다.
- 데이터베이스의 종류는 계층형,네트워크형 데이터베이스, 관계형 데이터베으 등이 있다.
- 계층형 데이터베이스는 트리 형태의 자료구조에 데이터를 저장하고 관리하며, 네트워크는 오너와 멤버 형태로 데이터를 저장한다
- 계층형 데이터베이스는 1대 N 관계를 표현한다.
- 네트워크 데이터 베이스는 1대N과 함계 M대N 표현도 가능하다
- 관계형 데이터베이스는 릴레이션에 데이터를 저장하고 관리한다.
- 관계형 데이터베이스는 릴레이션을 사용해서 집합 연산과 관계 연산을 할 수 있다.

![Untitled](images/SQLD/14.png)

- 데이터베이스 관리 시스템은 계층형 데이터베이스, 네트워크 데이터베이스,관계형 데이터베이스 등을 관리하기 위한 소프트웨어를 의미하며, 일명 DBMS라고 한다.

### 관계형 데이터베이스 집합연산과 관계연산

- 관계형 데이터베이스의 특징은 릴레이션을 사용해서 집합 연산과 관계 연산을 할 수 있다.

### 집합연산

합집합-두 개의 릴레이션을 하나로 합하는 것이다.

차집합-본래 릴레이션에는 존재하고 다른 릴레이션에는 존재하지 않는 것을 조회한다.

교집합-두 개의 릴레이션 간에 공통된 것을 조회한다

곱집합-각 릴레이션에 존재하는 모든 데이터를 조합하여 연산한다. 

### 관계연산

선택연산:릴레이션에서 조건에 맞는 행(튜플)만을 조회한다

투영연산:릴레이션에 조건에 맞는 속성만을 조회한다.

결합연산:여러 릴레이션의 공통된 속성을 사용해서 새로운 릴레이션을 만들어 낸다.

나누기연산:기준 릴레이션에서 나누는 릴레이션이 가지고 있는 속성과 동일한 값을 가지는 행을 추출하고 나누는 릴레이션의 속성을 삭제한 후 중복된 행을 제거하는 연산이다.

### 테이블의 구조

- 기본키는 하나의 테이블에서 유일성과 최소성, Not Null을 만족하면서 해당 테이블을 대표하는 것이다.
- 테이블은 행과 칼럼으로 구성된다. 그 중에서 행은 하나의 테이블에 저장되는 값으로 튜플 이라고 한다.
- 칼럼은 어떤 데이터를 저장하기 위한 필드로 속성 이라고도 한다.
- 외래키는 다른 테이블의 기본키를 참조 하는 칼럼이다.
- 외래키는 관계연산 중에서 결합연산(join)을 하기 위해서 사용한다

### SQL 종류

- SQL은 관계형 데이터베이스에 대해서 데이터의 구조를 정의, 데이터 조작, 데이터 제어 등을 할 수 있는 절차형 언어이다.
- 관계형 데이터베이스는 데이터베이스를 연결하고 SQL문을 사용하여 데이터베이스를 누구나 쉽게 사용할 수 있도록 한다.
- SQL은 ANSI/ISO 표준을 준수하기 때문에 데이터베이스 관리 시스템이 변경되어도 그대로 사용할 수 있다.

### SQL 표준

- ANSI/ISO SQL 표준:INNER JOIN, NATURAL JOIN,USING 조건, ON 조건절을 사용한다
- ANSI/ISO SQL3 표준:DBMS 벤더별로 차이가 있었던 SQL을 표준화하여 제정했다.

### SQL 종류

- SQL은 데이터 정의, 데이터조작,데이터 제어 등의 기능을 지원한다

(1) DDL- 관계형 데이터베이스의 구조를 정의하는 언어이다. 

             - CREATE,ALTER,DROP,RENAME,TRUNCATE 문이 있다.

(2)DML-테이블에서 데이터를 입력,수정,삭제,조회한다.

       - INSERT,UPDATE,DELETE,SELECT 문이 있다.

(3)DCL- 데이터베이스 사용자에게 권한을 부여하거나 회수한다.

           - GRANT,REBOKE문이 있다.

(4)TCL-트랜잭션을 제어하는 명령어이다 

           - COMMIT,ROLLBACK,SAVEPOINT

- DDL문은 데이터베이스 테이블을 생성하거나 변경,삭제하는 것으로 데이터를 저장할 구조를 정의하는 언어이다
- DML은 데이터 구조가 DDL로 정의되면 해당 데이터 구조에 데이터를 입력하거나 수정,삭제,조회할 수 있다.
- DCL은 DDL로 정의된 구조에 어떤 사용자가 접근할 수 있는지 권한을 부여하는 것이다.
- 작업의 순서를 보면 데이터베이스의 사용자에게 권한을 부여하고 , 권한이 부여되면 DDL로 데이터 구조를 정의한다.
- 데이터 구조가 정의되면 데이터를 입력한 후에 개발자 및 사용자가 그 데이터를 조회하는 것이다.

### 트랜잭션

- 트랜잭션은 데이터베이스의 작업을 처리하는 단위이다.

### 트랜잭션의 특성

원자성 - 트랜잭션은 데이터베이스 연산의 전부가 실행되거나 전혀 실행되지 않아야 한다.

       -즉, 트랜잭션의 처리가 완전히 끝나지 않았을 경우는 실행되지 않은 상태와 같아야 한다.

일관성-트랜잭션 실행 결과로 데이터베이스의 상태가 모순되지 않아야 한다. 

      -트랜잭션 실행 후에도 일관성이 유지되어야 한다

고립성-트랜잭션 실행 중에 생성하는 연산의 중간결과는 다른 트랜잭션이 접근할 수 없다.

      -즉, 부분적인 실행 결과를 다른 트랜잭션이 볼 수 없다.

영속성-트랜잭션이 그 실행을 성공적으로 완료하면 그 결과는 영구적 보장이 되어야 한다. 

### SQL문의 실행 순서

- 개발자가 작성한 SQL문 (DDL,DML,DCL 등) 3단계를 걸쳐서 실행된다. SQL 문의 문법을 검사하고 구문 분석을 한다.
- 구문 분석 이후에 SQL을 실행한다. SQL이 실행되면 데이터를 인출하게 된다.

### SQL 실행순서

- 파싱-SQL 문의 문법을 확인하고 구문 분석한다.

               -구문 분석한 SQL문은 LIBRARY CACHE에 저장한다

- 실행-옵티마이저가 수립한 실행 계획에 따라 SQL을 실행한다.
- 인출-데이터를 읽어서 전송한다

## DDL(Data Definition Language)

Create Table - 새로운 테이블을 생성한다.

                     - 테이블을 생성할때 기본키,외래키,제약사항 등을 설정할 수 있다. 

Alter Table - 생성된 테이블을 변경한다. 

                  - 칼럼을 추가하거나 변경,삭제할 수 있다.

                  - 기본키를 설정하거나,외래키를 설정할 수있다.

drop Table- 해당 테이블을 삭제한다.

                  - 테이블의 데이터 구조뿐만 아니라 저장된 데이터도 모두 삭제된다. 

### 기본적인 테이블 생성

![Untitled](images/SQLD/15.png)

- number는 칼럼의 데이터 타입을 숫자형 타입으로, varchar2는 가변 길이 문자열로 지정할 때 사용한다.
- char은 칼럼의 데이터 타입을 고정된 크기의 문자로 지정할 때, date는 날짜형 타입으로 지정할때 , 사용된다

![Untitled](images/SQLD/16.png)

(2) 제약조건 사용

- 기본키,외래키,기본값,not null 등은 테이블  생성할때 지정할 수 있다.

  

- 위의 예를 보면 “constraint” 를 사용하여 기본키(empno)와 기본키의 이름(emppk)를 지정할수 있다.
- 만약 위의 예에서 두 개의 기본키를 지정하고자 한다면 “constraint emppk primary key(empno,ename)” 으로 지정하면 된다.
- sal 칼럼은 number(10,2)로 지정했다. 이것은 소수점 둘째자리까지 저장하게 된다.
- oracle 데이터베이스에서 “sysdate” 는 오늘의 날짜를 조회한다. 이를 default 옵션을 사용해서 오늘 날짜를 기본값으로 지정할 수 있다.

![Untitled](images/SQLD/17.png)

- 외래키를 지정하려면, 먼저 마스터 테이블이 생성되어야 한다. 즉, 사원과 부서 테이블에서는 부서가 마스터 테이블이 된다.
- 즉, 사원 테이블이 부서 테이블의 deptno를 참조해야 하는 것이다.
- 그리고 EMP 테이블을 생성할 때 constraint를 사용하여 외래키 이름인 “deptfk”를 입력 후 외래키를 생성한다.

### (3) 테이블 생성시 CASCADE 사용

- 테이블을 생성할때 CASCADE 옵션을 사용할 수 있다. CASCADE 옵션은 참조관계(기본키와 외래키 관계) 가 있을 경우 참조되는 데이터를 자동으로 반영할 수 있는 것이다.
- 먼저, 마스터 테이블을 생성한다. 즉 DEPT 테이블을 생성하고 데이터를 입력한다

![Untitled](images/SQLD/18.png)

- 그 다음 EMP 테이블을 생성하고 데이터를 입력한다. 단, EMP 테이블을 생성할때, ON DELETE CASCADE 옵션을 사용한다.

![Untitled](images/SQLD/19.png)

- EMP 테이블을 생성하고 데이터 두 개를 입력한다.

![Untitled](images/SQLD/20.png)

- 위의 예제를 보면 dept 테이블에서 deptno가 1004번인 인사팀을 삭제했다.
- 그리고 emp 테이블의 데이터를 조회한 결과 deptno ‘1000’번 이었던 임베스트 데이터도 자동으로 삭제된 것을 알 수 있다.
- 즉,ON DELETE CASCADE 옵션은 자신이 참조하고 있는 테이블의 데이터가 삭제 되면 자동으로 자신도 삭제되는 옵션이다.
- ON DELETE CASCADE 옵션을 사용하면 참조 무결성을 준수할 수 있다. 참조무결성이란 마스터 테이블에는 해당 부서번호가 없는데 슬레이브 테이블에는 해당 부서번호가 있는 경우 참조 무결성 위배로 볼 수 있다.

### 테이블 변경

- ALTER TABLE문을 통해 테이블 변경을 할 수 있으며, 테이블명 변경, 칼럼추가,변경,삭제 등을 할 수 있다.

### (1) 테이블명 변경

- 테이블명 변경은 ALTER TABLE ~ RENAME TO 문을 사용하면 된다

![Untitled](images/SQLD/21.png)

### (2) 칼럼 추가

- 생성된 EMP 테이블에 ALTER TABLE ~ ADD 문을 사용해서 칼럼을 추가한다.

![Untitled](images/SQLD/22.png)

### (3) 컬럼변경

- 칼럼의 변경은 ALTER TABLE ~ MODIFY문을 사용하면 된다. 칼럼 변경을 통해 데이터 타입을 변경하거나 데이터의 길이를 변경할 수 있다.
- 칼럼을 변경할 때 제약조건을 설정할 수도 있다.
- 칼럼의 데이터 타입을 변경할 때 기존 데이터가 있는 경우 에러가 발생한다. 예를 들어 숫자 타입이고, 숫자 데이터가 저장되어 있는데 문자형 데이터 타입으로 변경하면 에러가 발생하는 것이다.

![Untitled](images/SQLD/23.png)

### (4)칼럼 삭제

- 칼럼에 대한 삭제는 ALTER TABLE ~ DROP COLUMN 문으로 삭제한다.

![Untitled](images/SQLD/24.png)

### (5) 칼럼명 변경

- 칼럼병 변경은 ALTER TABLE ~ RENAME COLUMN ~TO 문으로 변경 할수 있다.

![Untitled](images/SQLD/25.png)

### 테이블 삭제

- 테이블 삭제는  DROP Table문을 사용해서 삭제할 수 있다.
- DROP TABLE은 테이블의 구조와 데이터를 모두 삭제한다
- DROP TABLE 에서 “CASCADE CONSTRAINT” 옵션을 사용할 수 있다. “CASCADE CONSTRAINT” 옵션은 해당 테이블의 데이터를 외래키로 참조한 슬레이브 테이블과 관련된 제약사항도 삭제할 때 사용된다 .
- DROP TABLE EMP CASCADE CONSTRAINT;

### 뷰(VIEW) 생성과 삭제

- 뷰란 테이블로부터 유도된 가상의 테이블이다.
- 실제 데이터를 가지고 있지 않고, 테이블을 참조해서 원하는 칼럼만을 조회할 수 있게 한다.
- 뷰는 데이터 딕셔너리에 SQL문 형태로 저장하되 실행시에 참조된다.

### 뷰의 특징

- 참조한 테이블이 변경되면 뷰도 변경된다.
- 뷰의 검색은 참조한 테이블과 동일하게 할 수 있지만, 뷰에 대한 입력, 수정 ,삭제에는 제약이 있다
- 특정 칼럼만 조회시켜서 보안성을 향상 시킨다
- 한번 생성된 뷰는 변경할 수 없고 변경을 원하면 삭제 후 재생성해야 한다.
- ALTER 문을 사용해서 뷰를 변경할 수 없다.

- 뷰를 생성할 때 CREATE VIEW문을 사용하여 이때 참조할 테이블은 SELECT 문으로 지정한다.

 

![Untitled](images/SQLD/26.png)

- 뷰의 삭제는 ‘DROP VIEW’ 를 사용한다. 뷰를 삭제했다고 해서 참조했던 테이블이 삭제되지는 않는다

![Untitled](images/SQLD/27.png)

### 뷰의 장점과 단점

장점:1.특정 칼럼만 조회할 수 있기 때문에 보안기능이 있다.

   2.데이터 관리가 간단하다

    [3.SELECT](http://3.SELECT) 문이 간단해진다.

   4.하나의 테이블에 여러개의 뷰를 생성할 수 있다. 

단점: 1.뷰는 독자적인 인덱스를 만들 수 없다.

         2.삽입,수정삭제 연산이 제약된다

         3.데이터구조를 변경할수는 없다 

### DML(DATA Manipulation Language)

### INSERT문

### (1) INSERT 문

- INSERT문은 테이블에 데이터를 입력하는 DML문이다.

### INSERT문

INSERT INTO table (column1,column2) values (… , ….)

- EMP 테이블에 데이터를 삽입하려면 테이블명,칼럼명,데이터 순으로 입력하면 된다.

### SELECT 문

- SELECT문을 사용하여 데이터를 조회해서 해당 테이블에 바로 삽입할 수 있다.
- 단 입력되는 테이블은 사전에 생성되어 있어야 한다.

```sql

INSERT INTO DEPT_TEST SELECT * FROM DEPT;
DEPT 테이블의 모든 데이터를 조회해서 DEPT_TEST 에 넣는다.
```

### (3) NOLOGGING 사용

- 데이터 베이스에 데이터를 입력하면 로그파일에 그 정보를 기록한다
- check point라는 이벤트가 발생하면 로그파일의 데이터를 데이터 파일에 저장한다.
- NoLogging 옵션은 로그파일의 기록을 최소화시켜서 입력시 성능을 향상시키는 방법이다.
- Nologging 옵션은 Buffer Cache라는 메모리 영역을 생략하고 기록한다.

### UPDATE 문

- 입력된 데이터의 값을 수정하려면 UPDATE 문을 사용한다.
- UPDATE문을 사용하여 원하는 조건으로 데이터를 검색해서 해당 데이터를 수정할 수 있다.
- 만약,UPDATE문에 조건문을 입력하지 않으면 모든 데이터가 수정되므로 유의해야 한다.

```sql
UPDATE EMP
	SET ENAME='조조'
  WHERE EMPNO=100;
```

![Untitled](images/SQLD/28.png)

- UPDATE 문에서 주의사항은 데이터를 수정할 때 조건절에서 검색되는 행 수만큼 수정된다는 것이다.
- 앞의 예이서 DEPTNO=1111 인 사람이 두명이라면 두명 모두 조조로 수정된다.

### DELETE 문

- DELETE문은 원하는 조건을 검색해서 해당되는 행을 삭제한다.
- DELETE문에 조건문을 입력하지 않으면 모든 데이터가 삭제된다. 즉, 테이블에 있는 모든 데이터가 삭제되는 것이다.
- DELETE문으로 데이터를 삭제한다고 해서 테이블의 용량이 초기화 되지는 않는다.

![Untitled](images/SQLD/29.png)

- 만약 위의 예에서 WHERE절을 입력하지 않으면 EMP 테이블의 모든 데이터가 삭제 된다.

### 테이블 용량이 초기화 되지 않는다는 의미

- ORACLE 데이터베이스는 저장공간을 할당할때 저 EXTENT 단위로 할당한다.
- 테이블에 데이터가 입력되면 EXTENT에 저장하게 된다.
- 만약 EXTENT의 크기가 MAX_EXTENTS를 넘어서게 되면 용량 초과 오류가 발생하게된다. 즉, 최대로 저장할 수 있는 공간의 의미를 가지고 있다.
- DELETE문으로 데이터를 삭제하면 용량이 감소할 것으로 생각하는데,DELETE문은 삭제 여부만 표시하고 용량은 초기화되지 않는다.

![Untitled](images/SQLD/30.png)

### 테이블의 모든 데이터 삭제

### DELETE FROM 테이블명;

- 테이블의 모든 데이터를 삭제한다.
- 데이터가 삭제되어도 테이블의 용량은 감소하지않는다

### TRUNCATE TABLE 테이블명 ;

- 테이블의 모든 데이터를 삭제한다.
- 데이터가 삭제되면 테이블의 용량은 초기화 된다.

### SELECT문 사용

- 테이블에 입력된 데이터를 조회하기 위해서 SELECT문을 사용한다.
- SELECT문은 특정 칼럼이나 특정 행만을 조회한다.

![Untitled](images/SQLD/31.png)

### SELECT 칼럼 지정

사용예제

SELECT EMPNO,ENAME FROM EMP;  ⇒ EMP 테이블의 모든 행에서 EMPNO와 ENAME 칼럼만 출력한다.

SELECT * FROM EMP;  ⇒ EMP 테이블의 모든 칼럼과 모든 행을 조회한다.

SELECT ENAME || ‘님’ FROM EMP; ⇒ EMP 테이블의 모든 행에서 ENAME 칼럼을 조회한다. 

                                                           단,ENAME 칼럼 뒤에 ‘님’ 이라는 문자를 결합한다. 

### ORDER BY를 사용한 정렬

- SELECT문을 사용할 때 ORDER BY를 같이 사용할 수 있다
- ORDER BY는 데이터를 오름차순 혹은 내림차순 으로 출력한다.
- ORDER BY 가 정렬을 하는 시점은 모든 실행이 끝난 후에 데이터를 출력해 주기 바로 전이다.
- ORDER BY는 정렬을 하기 때문에 데이터베이스 메모리를 많이 사용하게 된다. 즉, 대량의 데이터를 정렬하게 되면 정렬로 인한 성능 저하가 발생한다.
- 정렬을 회피하기 위해서 인덱스를 생성할 때 사용자가 원하는 형태로 오름차순 혹은 내림차순으로 설정해야한다.
- 특별한 지정이 없으면 ORDER BY는 오름 차순으로 정렬한다.

```sql
SELECT * FROM EMP
	ORDER BY ENAME,SAL DESC;
-- ENAME 은 오름차순으로 정렬되고 , SAL은 내림차순으로 정렬된다-- 
```

### (3) INDEX를 사용한 정렬 회피

- 정렬은 ORACLE 데이터베이스에 부하를 주므로, 인덱스를 사용해서  ORDER BY를 회피할 수 있다.

![Untitled](images/SQLD/32.png)

- 위와 같이 데이터를 입력하고 SELECT문을 실행하면 EMPNO로 오름차순 정렬되어서 조회 된다.
- 그 이유는 EMPNO가 기본키이기 때문에 자동으로 오름차순 인덱스가 생성된다. ⇒ PRIMARY KEY에는 자동 INDEX 가 생성됨

![Untitled](images/SQLD/33.png)

- 위의 예를 보면 /*+ INDEX_DESC(A) */ 를 사용했다.. EMP 테이블에 생성된 인덱스를 내림차순으로 읽게 지정한 것이다.
- 따라서, SELECT문에 “ORDER BY EMPNO DESC” 를 사용하지 않았다.
- 위의 예처럼 SQL 문 사용하면 EMPNO 인덱스를 내림차순으로 읽는다.
- 인덱스를 스캔한 후에 해당 EMPNO의 값을 가지고 테이블의 데이터를 읽는다
- 테이블에서 해당 행을 찾으면 인출하여 사용자 화면에 조회된다.

### DISTINCT와 ALIAS

1. DISTINCT
- DISTINCT 문은 칼럼명 앞에 지정하여 중복된 데이터를 한 번만 조회 하게한다.

![Untitled](images/SQLD/34.png)

- DISTINCT 를 사용하면 EMPNO 값이 중복되지 않는다.

### ALIAS

- ALIAS(별칭)은 테이블명이나 칼럼명이 너무 길어서 간략하게 할 때 사용한다.

![Untitled](images/SQLD/35.png)

- 칼럼명을 이름으로 출력,EMP 테이블명 대신에 ‘a’를 사용한다.

### 부정 비교 연산자

- ! = :같지 않은 것을 조회한다.
- ^= :같지 않은것을 조회한다.

### 다중행 subquery

- 서브쿼리 결과가 2개 행 이상일 경우 다중행 서브쿼리라고 부릅니다.